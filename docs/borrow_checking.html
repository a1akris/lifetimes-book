<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Borrow checking</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="basics.html"><strong aria-hidden="true">2.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="borrow_checking.html" class="active"><strong aria-hidden="true">2.1.</strong> Borrow checking</a></li><li class="chapter-item expanded "><a href="lifetime_subtyping.html"><strong aria-hidden="true">2.2.</strong> Lifetime subtyping</a></li><li class="chapter-item expanded "><a href="intro_to_variance.html"><strong aria-hidden="true">2.3.</strong> Introduction to variance</a></li></ol></li><li class="chapter-item expanded "><a href="implied_bounds.html"><strong aria-hidden="true">3.</strong> A word about implied bounds</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="borrow-checking"><a class="header" href="#borrow-checking">Borrow checking</a></h1>
<p>The most important thing to understand about the borrow checker is it
analyzes each function completely independently from other functions.
That means when we encounter a call to our <code>post_urls_from_blog</code> the
borrow checker doesn't look inside it to validate the usage of references.
All it does is it reads the function signature and evaluates its lifetimes.
But what does it mean to evaluate a lifetime? Let's go back to our example
and figure this out.</p>
<p>As a borrow checker we're analyzing our <code>main</code> function and encountering a
line of code with another function invocation.</p>
<pre><code class="language-rust noplayground">let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();
</code></pre>
<p>First of all, we need to read the function signature:</p>
<pre><code class="language-rust noplayground">fn post_urls_from_blog&lt;'a&gt;(
    items: &amp;'a [DiscoveredItem], 
    blog_url: &amp;'a str,
) -&gt; impl Iterator&lt;Item = &amp;'a str&gt; {
    // We're looking at the function from the borrow checker's perspective.
    // It doesn't see the impl :(
}
</code></pre>
<p>See this <code>'a</code> we defined here? This is a generic lifetime. Sort of a placeholder.
We need to come up with a concrete value for it at every place we call the function.
To calculate it we need to adhere the following conditions:</p>
<ol>
<li>The lifetime value must be minimal.</li>
<li>References with this resulting lifetime value must stay valid for the whole lifetime value(no dangling pointers!)</li>
</ol>
<p>Ok, but that still sounds vague. What exactly is a lifetime value? Well, it's nothing more than a continuous<sup class="footnote-reference"><a href="#continuous">1</a></sup> region of code. 
Like from line X to line Y. The single line with the function invocation above is a perfect region of code. That's some another perfect region of code:</p>
<pre><code class="language-rust noplayground">/---region
|// Reading the blog URL we're interested in from somewhere
|let blog_url = get_blog_url(); 
|
|// Collecting post URLs from this blog using our function
|let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();
|
|// Spawning a thread to do some further blog processing
|let handle = std::thread::spawn(move || calculate_blog_stats(blog_url));
-
</code></pre>
<p>Region boundaries basically define where the refences can be used and the duration of the borrow.
<strong>All</strong> references belonging to the region must be safe to use at <strong>any</strong> line within the region.
All regions are function scoped. There are no &quot;cross-function&quot; regions. When we encounter
a function call in a function we currently analyze we just calculate a region for it
in the calling function based on the callee signature.</p>
<p>Now when we possess this secret knowledge we can formulate our task more precisely:
<em>At the function invocation point we need to infer some minimal regions of code that will &quot;hold&quot; our references 
with the guarantee that these references are safe to use at any line within the region they belong to.</em></p>
<h2 id="inferring-regions"><a class="header" href="#inferring-regions">Inferring regions</a></h2>
<p>Let's look at the <code>post_urls_from_blog</code> signature once again:</p>
<pre><code class="language-rust noplayground">fn post_urls_from_blog&lt;'a&gt;(
    items: &amp;'a [DiscoveredItem], 
    blog_url: &amp;'a str,
) -&gt; impl Iterator&lt;Item = &amp;'a str&gt; {
    // We're looking at the function from the borrow checker's perspective.
    // It doesn't see the impl :(
}
</code></pre>
<p>We see only one lifetime paramater which means we need to infer only one region for this function(Yes, we're inferring
regions for the whole function, not for each of its arguments).
This region must hold <code>items</code>, <code>blog_url</code>, <code>Item</code> references and... an iterator. The complete function
signature actually looks like that:</p>
<pre><code class="language-rust noplayground">fn post_urls_from_blog&lt;'a&gt;(
    items: &amp;'a [DiscoveredItem], 
    blog_url: &amp;'a str,
) -&gt; impl Iterator&lt;Item = &amp;'a str&gt; + 'a {
    // We're looking at the function from the borrow checker's perspective.
    // It doesn't see the impl :(
}
</code></pre>
<p>The compiler elided the last <code>'a</code> according to lifetime elision rules, so it was hidden from us. 
Now we have all information to perform the evaluation. I will evaluate the signature in a backwards order to quickly show the region expansion, 
but in general it's more natural to start from the input arguments.</p>
<p>How wide the region should be? As wide as all references it holds must stay valid. How long
the references must stay valid? As long as they're used. So, basically, a size of a region is determined
by the last reference usage this region holds. Let's apply this rule in practice. 
Our function returns an iterator <code>impl Iterator&lt;Item = &amp;'a str&gt; + 'a</code>. How is it used?</p>
<pre><code class="language-rust noplayground">let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();
</code></pre>
<p>Well, we just collect it immediately into a vector therefore, our region with respect of iterator
is a single line of code(the iterator is consumed and can't be used anywhere else):</p>
<pre><code class="language-rust noplayground">fn main() {
    let crawler_results = &amp;[
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned().to_owned(),
            post_url: &quot;https://blogs.com/cooking/fried_eggs&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned(),
            post_url: &quot;https://blogs.com/travelling/death_mountain&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://successfulsam.xyz/&quot;.to_owned(),
            post_url: &quot;https://successfulsam.xyz/keys_to_success/Just_do_this_one_thing_every_day&quot;.to_owned(),
        },
    ];

    let blog_url = get_blog_url(); 

/---post_urls_from_blog 'a region
|   let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();
-
    let handle = std::thread::spawn(move || calculate_blog_stats(blog_url));

    for url in post_urls {
        process_post(url);
    }

    handle.join().expect(&quot;Everything will be fine&quot;);
}
</code></pre>
<p>The consumed iterator yielded references <code>Item=&amp;'a str</code> that also belong to our region.
We store them in the <code>post_urls</code> vector. Now we need to find the last usage of those references.
It's here:</p>
<pre><code class="language-rust noplayground">    for url in post_urls {
        process_post(url);
    }
</code></pre>
<p>So <code>post_urls</code> references must be valid at least till the end of this loop. Expanding the region accordingly:</p>
<pre><code class="language-rust noplayground">fn main() {
    let crawler_results = &amp;[
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned().to_owned(),
            post_url: &quot;https://blogs.com/cooking/fried_eggs&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned(),
            post_url: &quot;https://blogs.com/travelling/death_mountain&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://successfulsam.xyz/&quot;.to_owned(),
            post_url: &quot;https://successfulsam.xyz/keys_to_success/Just_do_this_one_thing_every_day&quot;.to_owned(),
        },
    ];

    let blog_url = get_blog_url(); 

/---post_urls_from_blog 'a region
|   let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();
|
|   let handle = std::thread::spawn(move || calculate_blog_stats(blog_url));
|
|   for url in post_urls {
|       process_post(url);
|   }
-
    handle.join().expect(&quot;Everything will be fine&quot;);
}
</code></pre>
<p>As for input arguments, usually they don't affect the region expansion because
they must be valid only for the duration of a function call, but later we will study some cases when they do.
Let's evaluate <code>items: &amp;'a [DiscoveredItem]</code> and <code>blog_url: &amp;'a str</code> together. They're just
regular input references without any quirks, so they must be valid only at the line with the function invocation.
If we had started our analysis from input arguments, our region would look like that:</p>
<pre><code class="language-rust noplayground">fn main() {
    let crawler_results = &amp;[
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned().to_owned(),
            post_url: &quot;https://blogs.com/cooking/fried_eggs&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned(),
            post_url: &quot;https://blogs.com/travelling/death_mountain&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://successfulsam.xyz/&quot;.to_owned(),
            post_url: &quot;https://successfulsam.xyz/keys_to_success/Just_do_this_one_thing_every_day&quot;.to_owned(),
        },
    ];

    let blog_url = get_blog_url(); 

/---post_urls_from_blog 'a region
|   let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();
-
    let handle = std::thread::spawn(move || calculate_blog_stats(blog_url));

    for url in post_urls {
        process_post(url);
    }

    handle.join().expect(&quot;Everything will be fine&quot;);
}
</code></pre>
<p>But we've already analyzed the outputs and know that our region must be wider, hence the resulting
<code>'a</code> region of the <code>post_urls_from_blog</code> function looks like that:</p>
<pre><code class="language-rust noplayground">fn main() {
    let crawler_results = &amp;[
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned().to_owned(),
            post_url: &quot;https://blogs.com/cooking/fried_eggs&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned(),
            post_url: &quot;https://blogs.com/travelling/death_mountain&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://successfulsam.xyz/&quot;.to_owned(),
            post_url: &quot;https://successfulsam.xyz/keys_to_success/Just_do_this_one_thing_every_day&quot;.to_owned(),
        },
    ];

    let blog_url = get_blog_url(); 

/---post_urls_from_blog 'a region
|   let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();
|
|   let handle = std::thread::spawn(move || calculate_blog_stats(blog_url));
|
|   for url in post_urls {
|       process_post(url);
|   }
-
    handle.join().expect(&quot;Everything will be fine&quot;);
}
</code></pre>
<p>The region holds: a copy of the <code>crawler_results</code> reference, a reference to <code>blog_url</code>, a vector of <code>post_urls</code> references,
and the consumed iterator(yes, it's consumed at the first line of our region, but it still belongs to it).
Note that we didn't analyze any relationships between references. We don't understand
how inputs and outputs are connected and where the references point to. All we did is
we inferred a region for them where derefencing <strong>any</strong> of those references must
be safe. </p>
<p>We're done with our function. Regions for regular variables can be trivially inferred by following Rust scoping
rules. For example, this is the region for the <code>handle</code> variable:</p>
<pre><code class="language-rust noplayground">fn main() {
    let crawler_results = &amp;[
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned().to_owned(),
            post_url: &quot;https://blogs.com/cooking/fried_eggs&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned(),
            post_url: &quot;https://blogs.com/travelling/death_mountain&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://successfulsam.xyz/&quot;.to_owned(),
            post_url: &quot;https://successfulsam.xyz/keys_to_success/Just_do_this_one_thing_every_day&quot;.to_owned(),
        },
    ];

    let blog_url = get_blog_url(); 

    let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();
/---handle region
|   let handle = std::thread::spawn(move || calculate_blog_stats(blog_url));
|
|   for url in post_urls {
|       process_post(url);
|   }
|
|   handle.join().expect(&quot;Everything will be fine&quot;);
-
}
</code></pre>
<p>Try to infer regions for the remaining variables yourself.</p>
<h2 id="validating-regions"><a class="header" href="#validating-regions">Validating regions</a></h2>
<p>It's time to ensure the safety. After we inferred all regions in the
analyzed function we need to explore relationships between <strong>the regions</strong>(not variables) looking
for potential conflicts. Let's start at the point where the <code>crawler_results</code> reference is copied to be passed as an argument to the <code>post_urls_from_blog</code>
function. Can we create this copy? </p>
<pre><code class="language-rust noplayground">fn main() {
/---crawler results region
|   let crawler_results = &amp;[
|       DiscoveredItem {
|           blog_url: &quot;https://blogs.com/&quot;.to_owned().to_owned(),
|           post_url: &quot;https://blogs.com/cooking/fried_eggs&quot;.to_owned(),
|       },
|       DiscoveredItem {
|           blog_url: &quot;https://blogs.com/&quot;.to_owned(),
|           post_url: &quot;https://blogs.com/travelling/death_mountain&quot;.to_owned(),
|       },
|       DiscoveredItem {
|           blog_url: &quot;https://successfulsam.xyz/&quot;.to_owned(),
|           post_url: &quot;https://successfulsam.xyz/keys_to_success/Just_do_this_one_thing_every_day&quot;.to_owned(),
|       },
|   ];
|
|   let blog_url = get_blog_url(); 
|
|/--post_urls_from_blog 'a region
||  let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();
||
||  let handle = std::thread::spawn(move || calculate_blog_stats(blog_url));
||
||  for url in post_urls {
||      process_post(url);
||  }
|-
|   handle.join().expect(&quot;Everything will be fine&quot;);
-
}
</code></pre>
<p><code>crawler_resutls</code> region fills the whole <code>main</code> body clearly outliving our <code>post_urls_from_blog 'a</code> region meaning
we can dereference the copy of <code>crawler_results</code> reference at any line within the <code>post_urls_from_blog 'a</code> region
(note that we use <code>crawler_results</code> borrow only at the line with the function call, but it lasts till the end of the <code>post_urls_from_blog 'a</code> region anyway).</p>
<p>Then we're taking a reference to <code>blog_url</code>. Can we do that?</p>
<pre><code class="language-rust noplayground">fn main() {
    let crawler_results = &amp;[
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned().to_owned(),
            post_url: &quot;https://blogs.com/cooking/fried_eggs&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned(),
            post_url: &quot;https://blogs.com/travelling/death_mountain&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://successfulsam.xyz/&quot;.to_owned(),
            post_url: &quot;https://successfulsam.xyz/keys_to_success/Just_do_this_one_thing_every_day&quot;.to_owned(),
        },
    ];
/---blog_url region 
|   let blog_url = get_blog_url(); 
|
|/--post_urls_from_blog 'a region
||  let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();
||
||  let handle = std::thread::spawn(move || calculate_blog_stats(blog_url));
-|
 |  for url in post_urls {
 |      process_post(url);
 |  }
 -
    handle.join().expect(&quot;Everything will be fine&quot;);
 
}
</code></pre>
<p>No, we can't. We must be able to derefence this <code>blog_url</code> reference at any place within the <code>post_urls_from_blog 'a</code> region,
but there is no way of doing that around the for loop because <code>blog_url</code> region ends(variable moves out of scope) right before the loop.</p>
<p>Now we should be able to decipher the error message from the previous chapter:</p>
<pre><code>   Compiling playground v0.0.1 (/playground)
error[E0505]: cannot move out of `blog_url` because it is borrowed
  --&gt; src/main.rs:45:37
   |
42 |     let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();
   |                                                                  --------- borrow of `blog_url` occurs here
...
45 |     let handle = std::thread::spawn(move || calculate_blog_stats(blog_url));
   |                                     ^^^^^^^                      -------- move occurs due to use in closure
   |                                     |
   |                                     move out of `blog_url` occurs here
...
48 |     for url in post_urls {
   |                --------- borrow later used here

For more information about this error, try `rustc --explain E0505`.
error: could not compile `playground` due to previous error
</code></pre>
<p>Effectively it tells us that at line 42 compiler tries to take a reference to <code>blog_url</code> into a region that ends at line 48, but <code>blog_url</code> region
ends at line 45, so compiler can't do that. How can we fix this error? 
One way is to put the for loop before <code>std::thread::spawn</code>. This way the regions will be aligned and
<code>blog_url</code> will be safe to use at any line of the <code>post_urls_from_blog 'a</code> region. But our code is not executing in parallel this way. </p>
<pre><code class="language-rust noplayground">fn main() {
    let crawler_results = &amp;[
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned().to_owned(),
            post_url: &quot;https://blogs.com/cooking/fried_eggs&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned(),
            post_url: &quot;https://blogs.com/travelling/death_mountain&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://successfulsam.xyz/&quot;.to_owned(),
            post_url: &quot;https://successfulsam.xyz/keys_to_success/Just_do_this_one_thing_every_day&quot;.to_owned(),
        },
    ];
/---blog_url region 
|   let blog_url = get_blog_url(); 
|
|/--post_urls_from_blog 'a region
||  let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();
||
||  for url in post_urls {
||      process_post(url);
||  }
|-
|   let handle = std::thread::spawn(move || calculate_blog_stats(blog_url));
-
    handle.join().expect(&quot;Everything will be fine&quot;);
}
</code></pre>
<p>Another way is to get away with clones. But let's look at our region carefully:</p>
<pre><code class="language-rust noplayground">/---blog_url region 
|   let blog_url = get_blog_url(); 
|
|/--post_urls_from_blog 'a region
||  let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();
||
||  let handle = std::thread::spawn(move || calculate_blog_stats(blog_url));
-|
 |  for url in post_urls {
 |      process_post(url);
 |  }
 -
</code></pre>
<p>We don't really need the <code>blog_url</code> reference to be valid inside the for loop, we only care about <code>post_urls</code> there.
This <code>post_urls_from_blog 'a</code> region is essentially a region for our <code>post_urls</code>, the <code>blog_url</code> region could be much
smaller, but the function signature asks the compiler to infer only a single region, so the <code>blog_url</code> reference ends up coupled
with the <code>post_urls</code> references. What we actually want is to ask the compiler to infer 2 regions for this function: the one for <code>post_urls</code>
and the one for <code>blog_url</code>, so regions in <code>main</code> would look like that.</p>
<pre><code class="language-rust noplayground">/---blog_url region 
|   let blog_url = get_blog_url(); 
|
|/--post_urls_from_blog 'post_urls region
||/-post_urls_from_blog 'blog_url region
||| let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();
||-
||  let handle = std::thread::spawn(move || calculate_blog_stats(blog_url));
-|
 |  for url in post_urls {
 |      process_post(url);
 |  }
 -
</code></pre>
<p>This way <code>post_urls_from_blog 'blog_url</code> region is only 1-line long and borrowing <code>blog_url</code> for this line is fine, when <code>post_urls_from_blog 'post_urls</code> region
holds only <code>post_urls</code> references and doesn't care about the <code>blog_url</code> region at all. Let's try to split this <code>'a</code> region!</p>
<h2 id="splitting-post_urls_from_blog-a-region"><a class="header" href="#splitting-post_urls_from_blog-a-region">Splitting <code>post_urls_from_blog 'a</code> region</a></h2>
<p>To ask the compiler to infer 2 regions instead of 1 we just need to introduce a second lifetime parameter in the function signature:</p>
<pre><code class="language-rust noplayground">fn post_urls_from_blog&lt;'post_urls, 'blog_url&gt;(
    items: &amp;'post_urls [DiscoveredItem], 
    blog_url: &amp;'blog_url str,
) -&gt; impl Iterator&lt;Item = &amp;'post_urls str&gt; {
    // ...
}
</code></pre>
<p>We're taking post urls from input items, so <code>items</code> clearly belong to <code>post_urls</code> region. We use <code>blog_url</code> only for filtering, so it belongs to its own 
<code>blog_url</code> region. Iterator returns post urls from the input <code>items</code>, so <code>Item = &amp;str</code> must belong to <code>post_urls</code> region. But what about an <code>Iterator</code> itself?
We're iterating <code>items</code>, so let's assign it to <code>post_urls</code> region.</p>
<pre><code class="language-rust noplayground">fn post_urls_from_blog&lt;'post_urls, 'blog_url&gt;(
    items: &amp;'post_urls [DiscoveredItem], 
    blog_url: &amp;'blog_url str,
) -&gt; impl Iterator&lt;Item = &amp;'post_urls str&gt; + 'post_urls {
    // ...
}
</code></pre>
<p>Now we will infer new regions for the updated signature, but in a bit different context to
emphasize that borrow checker analyzes each function completely independetly:</p>
<pre><code class="language-rust noplayground">fn uaf(options: &amp;CrawlerOptions) {
    let items = crawler::run(options);

    let blog_url = get_blog_url();
    let iterator = post_urls_from_blog(&amp;items, &amp;blog_url);
    drop(blog_url);

    for url in iterator {
        do_stuff(url);
    }
}
</code></pre>
<p>Let's infer regions in the <code>uaf</code> function:</p>
<pre><code class="language-rust noplayground">fn uaf(options: &amp;CrawlerOptions) {
/---items region
|   let items = crawler::run(options);
|
|   let blog_url = get_blog_url();
|/--post_urls_from_blog 'post_urls region
||  let iterator = post_urls_from_blog(&amp;items, &amp;blog_url);
||  drop(blog_url);
||
||  for url in iterator {
||      do_stuff(url);
||  }
--
}
</code></pre>
<p><code>post_urls_from_blog 'post_urls</code> holds an iterator, and a reference to the <code>items</code> variable and it can dereference them at any line of this region
because <code>items</code> region outlives the <code>'post_urls</code> region.</p>
<pre><code class="language-rust noplayground">fn uaf(options: &amp;CrawlerOptions) {
    let items = crawler::run(options);
/---blog_url region
|   let blog_url = get_blog_url();
|/--post_urls_from_blog 'blog_url region
||  let iterator = post_urls_from_blog(&amp;items, &amp;blog_url);
|-  drop(blog_url);
-
    for url in iterator {
        do_stuff(url);
    }
  
}
</code></pre>
<p><code>post_urls_from_blog 'blog_url</code> region holds just a reference to the <code>blog_url</code> variable. It's an input argument, therefore the reference should be valid
only for the time of the function call, so the region is 1-line long. <code>blog_url</code> region clearly outlives this 1-line region, so it's safe to create a borrow
there. As the result the <code>uaf</code> function passes the borrow checking just perfectly, but if we think about what's going on, we quickly realize that the iterator
holds a reference to <code>blog_url</code> internally to do the comparisons, so in fact we have a use after free memory bug here. <code>post_urls_from_blog</code> function
signature doesn't tell anything about this internal borrow, so borrow checker can't spot any issue while analyzing the <code>uaf</code> function. Luckily for us
it can spot the issue during the analysis of the <code>post_urls_from_blog</code> function body which is done only once and independently from the <code>uaf</code> function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct DiscoveredItem {
</span><span class="boring">   blog_url: String,
</span><span class="boring">   post_url: String,
</span><span class="boring">}
</span>fn post_urls_from_blog&lt;'post_urls, 'blog_url&gt;(
    items: &amp;'post_urls [DiscoveredItem], 
    blog_url: &amp;'blog_url str,
) -&gt; impl Iterator&lt;Item = &amp;'post_urls str&gt; + 'post_urls {
    items.iter().filter_map(move |item| {
        if item.blog_url == blog_url {
            Some(item.post_url.as_str())
        } else {
            None
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>The borrow checker emits the following error for this implementation:</p>
<pre><code>error[E0623]: lifetime mismatch
  --&gt; src/main.rs:11:6
   |
10 |     blog_url: &amp;'blog_url str,
   |               -------------- this parameter and the return type are declared with different lifetimes...
11 | ) -&gt; impl Iterator&lt;Item = &amp;'post_urls str&gt; + 'post_urls {
   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |      |
   |      ...but data from `blog_url` is returned here

For more information about this error, try `rustc --explain E0623`.
error: could not compile `playground` due to previous error
</code></pre>
<p>It was able to spot that the iterator borrows <code>blog_url</code> from the <code>'blog_url</code> region, but the signature
suggests that the iterator borrows only from the <code>'post_urls</code> region, so the borrow checker threw a <code>lifetime mismatch</code> error.
In order to fix it we must reflect this <code>blog_url</code> borrow in our signature by assigning the iterator to the <code>'blog_url</code> region.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct DiscoveredItem {
</span><span class="boring">   blog_url: String,
</span><span class="boring">   post_url: String,
</span><span class="boring">}
</span>fn post_urls_from_blog&lt;'post_urls, 'blog_url&gt;(
    items: &amp;'post_urls [DiscoveredItem], 
    blog_url: &amp;'blog_url str,
) -&gt; impl Iterator&lt;Item = &amp;'post_urls str&gt; + 'blog_url {
    items.iter().filter_map(move |item| {
        if item.blog_url == blog_url {
            Some(item.post_url.as_str())
        } else {
            None
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<pre><code>   Compiling playground v0.0.1 (/playground)
error[E0623]: lifetime mismatch
  --&gt; src/main.rs:11:6
   |
10 |     blog_url: &amp;'blog_url str,
   |               -------------- this parameter and the return type are declared with different lifetimes...
11 | ) -&gt; impl Iterator&lt;Item = &amp;'post_urls str&gt; + 'blog_url {
   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |      |
   |      ...but data from `items` is returned here

For more information about this error, try `rustc --explain E0623`.
error: could not compile `playground` due to previous error
</code></pre>
<p>But compilation fails with the same error. However, the signature is fine and communicates what we want now. Hmm... It's time to resort to magic!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct DiscoveredItem {
</span><span class="boring">   blog_url: String,
</span><span class="boring">   post_url: String,
</span><span class="boring">}
</span>fn post_urls_from_blog&lt;'post_urls, 'blog_url&gt;(
    items: &amp;'post_urls [DiscoveredItem], 
    blog_url: &amp;'blog_url str,
) -&gt; impl Iterator&lt;Item = &amp;'post_urls str&gt; + 'blog_url
where
    'post_urls: 'blog_url
{
    items.iter().filter_map(move |item| {
        if item.blog_url == blog_url {
            Some(item.post_url.as_str())
        } else {
            None
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>And now everything compiles, including the example from the previous chapter.
Check it out:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct DiscoveredItem {
</span><span class="boring">   blog_url: String,
</span><span class="boring">   post_url: String,
</span><span class="boring">}
</span><span class="boring">fn post_urls_from_blog&lt;'post_urls, 'blog_url&gt;(
</span><span class="boring">   items: &amp;'post_urls [DiscoveredItem], 
</span><span class="boring">   blog_url: &amp;'blog_url str,
</span><span class="boring">) -&gt; impl Iterator&lt;Item = &amp;'post_urls str&gt; + 'blog_url
</span><span class="boring">where
</span><span class="boring">   'post_urls: 'blog_url
</span><span class="boring">{
</span><span class="boring">   items.iter().filter_map(move |item| {
</span><span class="boring">       if item.blog_url == blog_url {
</span><span class="boring">           Some(item.post_url.as_str())
</span><span class="boring">       } else {
</span><span class="boring">           None
</span><span class="boring">       }
</span><span class="boring">   })
</span><span class="boring">}
</span>fn main() {
    // Assume the crawler returned the following results
    let crawler_results = &amp;[
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned().to_owned(),
            post_url: &quot;https://blogs.com/cooking/fried_eggs&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://blogs.com/&quot;.to_owned(),
            post_url: &quot;https://blogs.com/travelling/death_mountain&quot;.to_owned(),
        },
        DiscoveredItem {
            blog_url: &quot;https://successfulsam.xyz/&quot;.to_owned(),
            post_url: &quot;https://successfulsam.xyz/keys_to_success/Just_do_this_one_thing_every_day&quot;.to_owned(),
        },
    ];

    // Reading the blog URL we're interested in from somewhere
    let blog_url = get_blog_url(); 

    // Collecting post URLs from this blog using our function
    let post_urls: Vec&lt;_&gt; = post_urls_from_blog(crawler_results, &amp;blog_url).collect();

    // Spawning a thread to do some further blog processing
    let handle = std::thread::spawn(move || calculate_blog_stats(blog_url));

    // Processing posts in parallel
    for url in post_urls {
        process_post(url);
    }

    handle.join().expect(&quot;Everything will be fine&quot;);
}

// Returns a predefined value
fn get_blog_url() -&gt; String {
    &quot;https://blogs.com/&quot;.to_owned()    
}

// Just prints URL out
fn process_post(url: &amp;str) {
    println!(&quot;{}&quot;, url);
}

// Actually does nothing
fn calculate_blog_stats(_blog_url: String) {}
</code></pre></pre>
<p>We will demistify the added <code>where</code> clause and will understand the last compilation error in the next chapter,
but before going further make sure you understood the material from this chapter.</p>
<h2 id="chapter-exercises"><a class="header" href="#chapter-exercises">Chapter exercises</a></h2>
<ol>
<li>The chapter says when we encounter a function call we need to infer minimal regions for it at the invocation point.
Why do we want these regions to be minimal?</li>
<li>Assume this signature compiles:</li>
</ol>
<pre><code class="language-rust noplayground">fn post_urls_from_blog&lt;'post_urls, 'blog_url&gt;(
    items: &amp;'post_urls [DiscoveredItem], 
    blog_url: &amp;'blog_url str,
) -&gt; impl Iterator&lt;Item = &amp;'post_urls str&gt; + 'blog_url {
    // ...
}
</code></pre>
<p>Go back to the <code>uaf</code> example. Infer and validate regions for the <code>uaf</code> using this <code>post_urls_from_blog</code> signature.
Does <code>uaf</code> compile?</p>
<div class="footnote-definition" id="continuous"><sup class="footnote-definition-label">1</sup>
<p>The book is written in the NLL era.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="basics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="lifetime_subtyping.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="basics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="lifetime_subtyping.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
